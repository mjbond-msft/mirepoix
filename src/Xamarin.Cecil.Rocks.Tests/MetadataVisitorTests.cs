// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;

using Xunit;

using Mono.Cecil;

namespace Xamarin.Cecil.Rocks
{
    public class MetadataVisitorTests
    {
        static readonly AssemblyDefinition TestAssemblyDefinition = AssemblyDefinition.ReadAssembly (
            typeof (MetadataVisitorTests).Assembly.Location);

        class TestVisitAssemblyDefinition : MetadataVisitor
        {
            int invocations;

            public override bool VisitAssemblyDefinition (AssemblyDefinition assemblyDefinition)
            {
                Assert.Equal (TestAssemblyDefinition, assemblyDefinition);
                Assert.Equal (1, ++invocations);
                return true;
            }
        }

        [Fact]
        public void VisitAssemblyDefinition ()
            => TestAssemblyDefinition.AcceptVisitor (new TestVisitAssemblyDefinition ());

        class TestVisitTypeDefinition : MetadataVisitor
        {
            class C<T1> { }
            class C<T1, T2> { }
            class C<T1, T2, T3> { public class A { } }
            class C<T1, T2, T3, T4> { public class A<A1> { } }
            enum E { }
            struct S { }

            public List<Type> ExpectedTypes { get; } = new List<Type> {
                typeof(ThisAssembly),
                typeof(ThisAssembly.Git),
                typeof(ThisAssembly.Git.BaseVersion),
                typeof(ThisAssembly.Git.SemVer),
                typeof(MetadataVisitorTests),
                typeof(TestVisitAssemblyDefinition),
                typeof(TestVisitTypeDefinition),
                typeof(C<>),
                typeof(C<,>),
                typeof(C<,,>),
                typeof(C<,,>.A),
                typeof(C<,,,>),
                typeof(C<,,,>.A<>),
                typeof(E),
                typeof(S)
            };

            public override bool VisitTypeDefinition (TypeDefinition typeDefinition)
            {
                var fullName = typeDefinition.FullName.Replace ('/', '+');
                switch (fullName) {
                case "<Module>":
                case "AutoGeneratedProgram":
                    return true;
                }

                for (int i = ExpectedTypes.Count - 1; i >= 0; i--) {
                    if (ExpectedTypes [i].FullName == fullName) {
                        ExpectedTypes.RemoveAt (i);
                        return true;
                    }
                }

                throw new Exception ($"{typeDefinition} is unexpected");
            }
        }

        [Fact]
        public void VisitTypeDefinition ()
        {
            var visitor = new TestVisitTypeDefinition ();
            TestAssemblyDefinition.AcceptVisitor (visitor);
            Assert.Empty (visitor.ExpectedTypes);
        }
    }
}